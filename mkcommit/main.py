import argparse
import glob
import os
from typing import Callable, Optional, Union
from InquirerPy import inquirer
from enum import Enum
import importlib.util
import inspect
import sys
import pyperclip
import subprocess

from mkcommit.model import (
    CommitMessage, FailedToFindCommitMessageException, ModuleLoaderException, NotAGitRepoException,
    WrongModeException, NoFilesFoundException, select, confirm
)


class Mode(Enum):
    STDOUT = "stdout"
    CLIPBOARD = "clipboard"
    BOTH = "both"
    RUN = "run"


def to_stdout(msg: Union[str, CommitMessage]):
    if type(msg) is CommitMessage:
        print(msg.make())
    else:
        print(msg)


def to_clipboard(msg: Union[str, CommitMessage]):
    if type(msg) is CommitMessage:
        pyperclip.copy(msg.make())
    else:
        pyperclip.copy(msg)


def to_cmd(msg: Union[str, CommitMessage]):
    if type(msg) is CommitMessage:
        msg_str = msg.make()
    else:
        msg_str = msg
    yes = confirm(f"The commit message is:\n{msg_str}\n Confirm?")
    if yes:
        subprocess.call(("git", "commit", "-m", "msg_str"))
    else:
        print("Canceling.")


def _main(
    file: str,
    mode: Mode,
    to_stdout: Callable[[Union[str, CommitMessage]], None] = to_stdout,
    to_clipboard: Callable[[Union[str, CommitMessage]], None] = to_clipboard
):
    commit_message_instance: Optional[CommitMessage] = None
    module_shim = "mkcommit.loaded_config"
    spec = importlib.util.spec_from_file_location(
        module_shim,
        file
    )

    if spec:
        cfg_module = importlib.util.module_from_spec(spec)
        if spec.loader:
            getattr(spec.loader, "exec_module")(cfg_module)
        else:
            raise ModuleLoaderException(
                f"Loaded module ({file}) spec does not have a valid loader"
            )
        sys.modules[module_shim] = cfg_module
    else:
        raise ModuleLoaderException(f"Could not load module located at {file}")

    for name, obj in inspect.getmembers(sys.modules[module_shim]):
        if isinstance(obj, CommitMessage):
            commit_message_instance = obj

    if commit_message_instance is None:
        raise FailedToFindCommitMessageException(
            f"Module {file} seems to not declare any instance "
            "of a `CommitMessage` class. Did you forget to instantiate?"
        )
    else:
        if mode == mode.STDOUT:
            to_stdout(commit_message_instance)
        elif mode == mode.CLIPBOARD:
            to_clipboard(commit_message_instance)
        elif mode == mode.BOTH:
            to_stdout(commit_message_instance)
            to_clipboard(commit_message_instance)
        elif mode == mode.RUN:
            to_cmd(commit_message_instance)
        else:
            raise WrongModeException(f"You've used invalid mode: {mode}")


def configurator():
    parser = argparse.ArgumentParser(description="mkcommitconfig")
    parser.add_argument(
        "--addhook",
        action="store_true",
        help="Install `mkcommit` as a git pre-commit hook in the current repo"
    )
    parser.add_argument(
        "--removehook",
        action="store_true",
        help="Remove `mkcommit` from `pre-commit` hooks"
    )
    
    args = parser.parse_args()
    
    if args.addhook or args.removehook:
        if not os.path.exists(".git"):
            raise NotAGitRepoException(f"{os.getcwd()} is not a git repo!")
        else:
            precommit_path = ".git/hooks/pre-commit"
            if os.path.exists(".git"):
                if os.path.exists(precommit_path):
                    with open(precommit_path, "r") as f:
                        contents = f.read()
                else:
                    open(precommit_path, "w").close()
                    contents = ""
                if args.addhook:
                    if "mkcommit" in contents:
                        print(f"`mkcommit` has already been configured for repo {os.getcwd()}")
                    else:
                        with open(precommit_path, "a") as f:
                            f.write("mkcommit")
                        print(f"`mkcommit` hook installed for local repo {os.getcwd()}")
                else:
                    if "mkcommit" in contents:
                        with open(precommit_path, "r") as f:
                            contents = f.read()
                        with open(precommit_path, "w") as f:
                            f.write(contents.replace("mkcommit", ""))
                        print(f"`mkcommit` hook removed for repo {os.getcwd()}")
                    else:
                        print(f"`mkcommit` has never been installed for repo {os.getcwd()}")


def main():
    parser = argparse.ArgumentParser(
        description="`mkcommit` runs `git commit` with an autogenerated message"
    )

    # subparsers = parser.add_subparsers()
    # parser_mk = subparsers.add_parser("mk", help="Create commit messages from templates")
    # parser_lint = subparsers.add_parser("lint", help="Lint a commit message")
    # parser_config = subparsers.add_parser("config", help="Configure `mkcommit`")

    parser.add_argument('-c', '--clipboard',
                        action='store_true', help="Send message to the clipboard instead of STDOUT")
    parser.add_argument('-f', '--file',
                        type=str, help="Path to the commit config file. Must be a "
                        "Python file with `*.mkcommit.py` extension and declaring an instance of "
                        "`mkcommit.CommitMessage` class."
                        )
    parser.add_argument('-s', '--stdout',
                        action='store_true', help="Executes `git commit -m` with whatever output "
                        "was produced by `mkcommit`"
                        )

    args = parser.parse_args()

    if args.clipboard and args.stdout:
        mode = Mode.BOTH
    elif args.clipboard:
        mode = Mode.CLIPBOARD
    elif args.stdout:
        mode = Mode.STDOUT
    else:
        mode = Mode.RUN  # Run is default mode

    if args.file:
        _main(args.file, mode)
    else:
        mkcommit_files = glob.glob("*.mkcommit.py")
        if os.path.exists(".mkcommit.py"):
            # add also a dotfile if no prefix is used
            mkcommit_files.append(".mkcommit.py")
        if len(mkcommit_files) == 0:
            raise NoFilesFoundException("No `*.mkcommit.py` files found")
        selected_file = select(
            "Select one of the following files I've found", mkcommit_files)
        if type(selected_file) is str:
            _main(selected_file, mode)
        else:
            raise TypeError("Result was not a string. This is a bug!")


if __name__ == "__main__":
    main()
